# INSERT CONSTANTS AND FUNCTIONS USED ACROSS ALL QUESTIONS HERE

# build pile play types
INVALID_PLAY = 0
VALID_NONFINAL_PLAY = 1
VALID_FINAL_PLAY = 2
NO_PLAY = 3

def check_input(play, player_no, hand, stockpiles, discard_piles, build_piles):
    '''
    This function has six inputs, all inputs are same as 
    comp10001bo_is_valid_play's inputs. This function will check all inputs are
    valid, especially check the length of inputs and int exceed the index or 
    not. If the inputs are invalid, will return False; else return True
    '''
    
    # Check build_piles length
    if len(build_piles) != 4:
        return False
    
    # Check stockpiles length
    elif len(stockpiles) != 4:
        return False
    # Check discard_piles length
    elif len(discard_piles) != 4:
        return False
    
    # Check the hand cards are not exceed 5 pieces
    elif len(hand) > 5:
        return False
    
    # Sitution 1: The play card from hand
    elif play[0] == 0:
        
        # Check the play card is exist in hand
        if play[1] not in hand:
            return False
        
        # Sitution 1.1: The play card goes to build piles
        elif play[2][0] == 0:
            
            # Check the build pile no. is not exceed actual numbers of piles
            if play[2][1] > 3:
                return False
            
            # Check the build pile no. is not invalid
            elif play[2][1] < 0:
                return False
    
    # Sitution 2: The play card from discard
    elif play[0] == 1:
        
        # Check plap card source and destination are not same
        if play[1][1] == play[2][1]:
            return False
        
        # Check the number ofpiles for each player in discard piles is four
        for i in range(len(discard_piles)):
            if len(discard_piles[i]) != 4:
                return False
            
        # discard is a list contain all top cards from every discard piles    
        discard = []    
        for i in range(len(discard_piles)):
            for j in range(4):

                if discard_piles[i][j] != []:
                    discard.append(discard_piles[i][j][-1])
        
        # Check the play card is a top card from one discard pile
        if play[0] == 1 and play[1][0] not in discard:
            return False
    
    # Sitution 2: play card from stockpile
    elif play[0] == 2:
        
        # Check play card is the top card from player's stock pile 
        if play[1] != stockpiles[player_no][0]:
            return False
    
    # Check the player_no is from 0 to 3
    elif player_no > 3 or player_no < 0:
        return False
    
    else:
        return True
 
    
def get_card(play, discard_piles):
    '''
    This function has two inputs, play is a tuple contain play card type, 
    play card source and play card distination; discard_piles is all piles of 
    discard. This function will get the play card and return a string represent
    the play card.
    '''
    
    # Sitution 1: Get the card from discard piles 
    if play[0] == 1:
        return play[1][0]
    
    # Sitution 2: When no possible play, return None
    elif play[0] == 3:
        return None
    
    # Sitution 3: Get the card from source when card from hand or stock piles
    else:
        return play[1]
    
    
def get_pile(play, discard_piles):
    '''
    This function has two inputs, play is a tuple contain play card type, 
    play card source and play card distination; discard_piles is all piles of 
    discard. This function will get the discard pile that is the destination of 
    play card. And it will return a list to represent the pile
    '''
    return discard_piles[play[2][1][0]][play[2][1][1]]


def check_hand(play):
    '''
    This function has one input, play is a tuple contain play card type, 
    play card source and play card distination. This function will check the 
    play card is from hand or not and return a bool: Ture if it is from hand;
    False if it is not from hand.
    '''
    if play[0] == 0:
        return True
    
    else:
        return False

    
def get_all_play_cards(play, player_no, hand, stockpiles, discard_piles):
    '''
    This function has five inputs. play is a tuple contain play card type, 
    play card source and play card distination; player_no is a int represent 
    the player number; hand is a list represent all hand card from the player; 
    stockpiles is a 4-tuple describe the all stock piles, contain the top cards
    and how many card in the pile; discard_piles is all piles of discard. 
    This function will get all card that can be used. It will return a list 
    contain all cards from hand, the top card from player's stock pile and top 
    card from each discard piles.
    '''
    
    # all_card is a list contain hand card, top stock card and top discards
    all_card = []
    
    # card is the card in hand
    for card in hand:
        
        # Get the cards from hand
        all_card.append(card)
    
    # Get the card from stock pile
    all_card.append(stockpiles[player_no][0])

    # players is the no. of each discard piles
    for players in range(len(discard_piles)):
        
        # If the discard pile is empty, pass
        if discard_piles[players][-1] != []:
            
            # Get top card from discard piles
            all_card.append(discard_piles[players][-1])
   
    return all_card


def get_play_card(play, player_no, hand, stockpiles, discard_piles):
    '''
    This function has five inputs, all are same as previous function.
    This function will get all card that can be used except hand.
    It will return a list contain all cards from hand, the top card from 
    player's stock pile and top card from each discard piles.
    '''
    
    # card is a list will conatin all cards can be played except hand
    card = []
    
    # stock_card is a list will get the top card from player's stock pile
    stock_card = []
    
    # Change the stock card type to list like ["xx"]
    stock_card.append(stockpiles[player_no][0])
    
    card.append(stock_card)
    
    # players is the no. of each discard piles
    for players in range(len(discard_piles)):
        
        # Only get non-empty pile
        if discard_piles[players][-1] != []:
            
            card.append(discard_piles[players][-1])
   
    return card
                  
    
def get_all_discard_piles(discard_piles):
    '''
    This function has an input, discard_piles is all piles of discard. 
    This function will return a list to represent all the piles from discard.
    '''
    
    # all_pile will contain all piles from discard pile in a list
    all_pile = []
    
    # player is the no. of each discard piles
    for player in range(len(discard_piles)):
        # pile is the pile number of the piles from a player's discard pile
        for pile in range(4):
            
            # discardpile is a list 
            discardpile = []
            
            # Get the top card from non_empty pile
            if discard_piles[player][pile] != []:
                
                discardpile.append(discard_piles[player][pile][-1])
                
                # Add top card to total pile list
                all_pile.append(discardpile)
            
            # Get empty pile 
            else:
                all_pile.append([])
    
    return all_pile
                
    
def check_possible(play, player_no, hand, stockpiles, discard_piles, 
                   build_piles):
    '''
    This function has six inputs, all are same as comp10001bo_is_valid_play's.
    This function will check the play is able to play or not. If checked there 
    is a possible play, return False, if there no possible play, return True
    '''
    
    # all_play_cards is all the card that can be play
    all_play_cards = get_all_play_cards(play, player_no, 
                                        hand, stockpiles, discard_piles)
    
    # play_cards is all the card that can be play except hand card
    play_cards = get_play_card(play, player_no, 
                               hand, stockpiles, discard_piles)
    
    # play_piles is all the discard pile that can be destination
    play_piles = get_all_discard_piles(discard_piles)
    
    # build_list is list to record all the possible play to build piles
    build_list = []
    
    # card is the no. of card in all_play_cards
    for card in range(len(all_play_cards)):
        # pile is the pile in build_piles
        for pile in build_piles:
            
            # check there is possible play to build piles or not
            if comp10001bo_match_build(all_play_cards[card], pile):
                
                # if have possible play, the build_list adds a "Possible"
                build_list.append("Possible")
    
    # If the list not empty, means there is possible play, then return False
    if build_list != []:
        return False
     
    # discard_hand_list is list to record all the possible play to discard pile 
    discard_hand_list = []  # only play with hand cards
    
    # card is the the no. of hand cards
    for card in range(len(hand)):
        
        # pile is the no. of discard piles
        for pile in range(len(play_piles)):
            
            # Get the owner of discard pile 
            if pile < 3:
                to_player = 0
            elif pile > 3 and pile < 8:
                to_player = 1
            elif pile > 7 and pile < 12:
                to_player = 2
            elif pile > 11 and pile < 16:
                to_player = 3
            
            # Check there is valid play to discard pile from hand or not
            if comp10001bo_match_discard(hand[card], play_piles[pile], 
                                         player_no, to_player, True) != 0:
                # Add "Possible" if valid play
                discard_hand_list.append("Possible")
    
    # Return False if there is valid play
    if discard_hand_list != []:
        return False
    
    # discard_hand_list is list to record all the possible play to discard pile 
    discard_nonhand_list = []  # play card not contain hand
    
    # As same as previous loop
    for card in range(len(play_cards)): 
        for pile in range(len(play_piles)):
        
            if pile < 3:
                to_player = 0
            elif pile > 3 and pile < 8:
                to_player = 1
            elif pile > 7 and pile < 12:
                to_player = 2
            elif pile > 11 and pile < 16:
                to_player = 3

            if comp10001bo_match_discard(play_cards[card][0], play_piles[pile],
                                         player_no, to_player, False) != 0:
                discard_nonhand_list.append("Possible")

    if discard_nonhand_list != []:
        return False
    
    # If there is no volid play, return True
    else:
        return True
               

def comp10001bo_is_valid_play(play, player_no, hand, stockpiles, discard_piles,
                              build_piles):
    '''
    This function has six inputs, This function has five inputs. play is a 
    tuple contain play card type, play card source and play card distination; 
    player_no is a int represent the player number; hand is a list represent 
    all hand card from the player; stockpiles is a 4-tuple describe the all 
    stock piles, contain the top cards and how many card in the pile; 
    discard_piles is all piles of discard; build_piles is a tuple contain four 
    build piles 
    '''
    
    # Check the input, if invalid, return 0
    if check_input(play, player_no, hand, stockpiles, discard_piles, 
                   build_piles) is False:
        return 0
    
    # Sitution 1: play card to build pile
    elif play[2][0] == 0:
        
        # result is the output of comp10001bo_match_build, a bool.
        result = comp10001bo_match_build(get_card(play, discard_piles), 
                                         build_piles[play[2][1]])
        
        # If play valid, return 1
        if result:
            return 1
        
        # If play invalid, return 2
        if result is False:
            return 0
    
    # Sitution 2: play card to discard pile
    elif play[2][0] == 1:
        
        # result is a int that is the output of comp10001bo_match_discard
        result = comp10001bo_match_discard(get_card(play, discard_piles), 
                                           get_pile(play, discard_piles), 
                                           player_no, play[2][1][0], 
                                           check_hand(play))
        return result
    
    # Sitution 3: No play is possible
    elif play[0] == 3:
        
        # Use check_possible function to check
        if check_possible(play, player_no, hand, stockpiles, discard_piles, 
                          build_piles):
            
            # If no possible play, return 3
            return 3
        
        # If has possible play, return 0
        else:
            return 0
        

def get_value(card):
    '''
    This function will take one argument "card", which is string for the poker 
    card. This function is used to get the value of the numbe part of the 
    poker, because there are some illogic character in the number part of the 
    "card", which are "A" means 1, "0" means 10, "J" means 11, "Q" means 12, 
    "K" means 13. This function will check the "card" has these illogic 
    character or not. If has, the function will return the real meaning of the 
    illogic character in int type; if doesn't have, the function will return 
    the number part in int type.
    '''
    # Check the illogic character
    if card[0] == "A":
        value = 1  # value is an int, means the number part of card
        
    elif card[0] == "0":
        value = 10
        
    elif card[0] == "J":
        value = 11
        
    elif card[0] == "Q":
        value = 12
        
    elif card[0] == "K":
        value = 13
    
    else:
        value = int(card[0])
    
    # Return the number part in int type
    return value


def check_build_value(play_card, build_pile):
    '''
    This function will take two arguments, one is a str "play_card", the card 
    that try to place onto build pile; the other one is a list "build_pile", 
    the pile is the card will placed on. The function will check the colour of 
    card and the top card of build pile are same or not and the number of card 
    and the top card of build pile are adjacent or not. If both colour and 
    number checked as right, return Ture, otherwise, return False.
    '''
    # build is the top card of the build pile
    build = build_pile[-1]
    
    # colour_check is to check the card colour and build pile colour are same
    colour_check = False  # initially False
    
    # number_check is to check the card number and build pile's are adjacent
    number_check = False  # initially False
    
    # get the number part of card in int type as card_value by function
    card_value = get_value(play_card)
    
    # get the number part of build pile in int type as build_value by function
    build_value = get_value(build)
    
    # Check the number part are adjacent, the number_check become True if right
    if abs(card_value - build_value) == 1:
        number_check = True
    
    # Check the colour part are same, if right, the colour_check becomes True
    if play_card[1] in "SC" and build[1] in "SC":
        colour_check = True
        
    elif play_card[1] in "HD" and build[1] in "HD":
        colour_check = True
    
    # check both colour and number are right, return True
    if colour_check and number_check:
        return True
    
    # Otherwise, return False
    else:
        return False

    
def check_discard_value(play_card, discard_pile):
    '''
    This function will take two arguments, one is a str "play_card", the card 
    that try to place onto discard pile; the other one is a list 
    "discard_pile",the pile is the card will placed on. The function will check
    the colour of card and the top card of discard pile are different or not 
    and the number of card and the top card of build pile are adjacent or not. 
    If both colour and numbe checkedas right, return Ture, otherwise, 
    return False.
    '''
    k_to_2_value = 13 - 2
    # discard is the top card of the discard pile
    discard = discard_pile[-1]
    
    # colour_check is to check the card colour and discard colour are different
    colour_check = False  # initially False
    
    # number_check is to check the card number and discard's are adjacent
    number_check = False  # initially False
    
    # get the number part of card in int type as card_value by function
    card_value = get_value(play_card)
    
    # get the number part of discard pile in int as discard_value by function
    discard_value = get_value(discard)
    
    # Check the number part are adjacent, the number_check become True if right
    if (abs(card_value - discard_value) == 1 or 
            abs(card_value - discard_value) == k_to_2_value):
        number_check = True
    
    # Check the colour part are different, the colour_check is True if right
    if play_card[1] in "SC" and discard[1] in "HD":
        colour_check = True
        
    elif play_card[1] in "HD" and discard[1] in "SC":
        colour_check = True
    
    # check both colour and number are right, return True
    if colour_check and number_check:
        return True
    
    # Otherwise, return False
    else:
        return False
    
    
def comp10001bo_match_build(play_card, build_pile):    
    '''
    This function will take two arguments, one is a str "play_card", the card 
    that try to place onto build pile; the other one is a list "build_pile", 
    the pile that the card will placed on. This function will check the build 
    pile is empty or it will be finished; and check number and colour by using 
    previous function. If all checked right, the card will be placed legally, 
    so return True; if checked the card placed illegally, the function will 
    return False.
    '''
    if build_pile != []:
        build = build_pile[-1]
    
    # check the build pile is empty or not
    if build_pile == []:
        
        # the empty build pile only can be started by 2 or K
        if play_card[0] == "2" or play_card[0] == "K":
            return True
        
        else:
            return False
    
    # check the build pile will be forced to complete by placing "A" or not
    elif play_card[0] == "A":
        
        if ((play_card[1] in "SC" and build[1] in "SC") or 
                (play_card[1] in "HD" and build[1] in "HD")):

            return True
    
    else:
        # using check_value function check colour and number
        if check_build_value(play_card, build_pile):
            return True
        
        else:
            return False
        
def comp10001bo_match_discard(play_card, discard_pile, player_no, to_player_no,
                              from_hand=True):
    '''
    This function will take five arguments, one is a str "play_card", the card 
    that try to place onto discard pile; the second one is a list 
    "discard_pile", the pile that the card will placed on, the third one is the
    player number and the fourth one is the owner of discard pile, these to is 
    to check is the person play on his or her own discard or not, the last one 
    is from_hand, which is a bool, it is True if the play_card is from player's
    hand. This function will check the play is valid or invalid and return a 
    int, 0 is means the play is invalid; 1 is means the play is non-turn-ending
    play; 2 is means the play is valid turn-ending play.
    '''
    # The discard pile cannot occur "A" in any sitution, if play card is A,
    # return 0
    if play_card[0] == "A":
        return 0
    
    # Check the pile is empty or not
    elif discard_pile == []:
        
        # Check the card to start pile is from pile owner's hand
        if player_no == to_player_no and from_hand:
            return 2
        
        # If not, is invalid play
        else:
            return 0
    
    # Check the colour and number by function, if correct, is valid play
    elif check_discard_value(play_card, discard_pile):
        return 1
    
    # Check the illegal play is from hand if not is invalid play
    elif (check_discard_value(play_card, discard_pile) is False and 
          from_hand is False):
        return 0
    
    # Check it is illegal play and means turn-ending play
    elif check_discard_value(play_card, discard_pile) is False:
        return 2
    
    # All the other sitution is inlegal
    else: 
        return 0

def get_discard_card(discard_piles):
    '''
    This function will take one argument, discard_piles is a 4-tuple describe
    the content of he discard piles for each players. This function will return
    two list, one is discard_card, contain all the cards in discard piles; the 
    other one is discard_position, contain a 2-turple to describe the location 
    of each card.
    '''
    # discard_card is a list will contain all discards from every player
    discard_card = []
    
    # discard_position, a list will contain all position of each discard cards
    discard_position = []
    
    for player in range(len(discard_piles)):
        for pile in range(len(discard_piles[player])):
            
            # Get the card in non-empty piles
            if discard_piles[player][pile] != []:
                
                discard_card.append(discard_piles[player][pile][-1])
                
                discard_position.append((player, pile))
    
    return discard_card, discard_position
    

def discard_pile_owner(discard_piles, pile):
    '''
    This function will take one argument, pile is the pile number of current 
    discard pile in the loop. This function will return a int represent the 
    '''
    # to_player is the owner of the play card destination pile
    if pile >= 0 and pile < (len(discard_piles) * 1):
        to_player = 0
    
    elif pile >= (len(discard_piles) * 1) and pile < (len(discard_piles) * 2):
        to_player = 1
        
    elif pile >= (len(discard_piles) * 2) and pile < (len(discard_piles) * 3):
        to_player = 2
        
    elif pile >= (len(discard_piles) * 3) and pile < (len(discard_piles) * 4):
        to_player = 3
    
    return to_player
        
        
def get_all_play(player_no, hand, stockpiles, discard_piles, build_piles):
    '''
    This function will contain five arguments, play_no is an integer represent 
    the player number; hand is a list contain all hand card of the player; 
    stockpiles is a 4-tuple describe the content of the stockpiles for each 
    player and the number of stockcard they have; discard_piles is a 4-tuple 
    describe the content of he discard piles for each players; build_piles is a
    4-tuple of list of card contain the content of the build piles.
    This function will return two list, play_list will contain all the
    avaliable plays that will not end this turn; play_end_list will contain all
    the avaliable plays that will end this turn.
    '''
    
    # A list will contain all avaliable non-ending play
    play_list = []
    
    # A list will contain all avaliable ending play
    play_end_list = []
    
    # The stock_card is the top card from the current player's stockpile
    stock_card = stockpiles[player_no][0]
    
    # discard_card is all the discard cards
    discard_card = get_discard_card(discard_piles)[0]
    
    # discard_position is the location of each discard card
    discard_position = get_discard_card(discard_piles)[1]
    
    # all_discard_pile is a list contain all the 16 discard piles
    all_discard_pile = get_all_discard_piles(discard_piles)
    
    # Sitution 1: play card from hand to build piles
    for card in hand:
        for pile in range(len(build_piles)):
            
            if comp10001bo_match_build(card, build_piles[pile]):
               
                play_list.append((0, card, (0, pile)))
    
    # Sitution 2: play card from stock pile to build piles
    for pile in range(len(build_piles)):
        
        if comp10001bo_match_build(stock_card, build_piles[pile]):
           
            play_list.append((2, stock_card, (0, pile)))
    
    # Sitution 3: play card from discard piles to build piles
    for card in range(len(discard_card)):
        for pile in range(len(build_piles)):
            
            if comp10001bo_match_build(discard_card[card], build_piles[pile]):
              
                play_list.append((1, (discard_card[card], 
                                      discard_position[card]), (0, pile)))
    
    # Sitution 4: play card from hand to discard piles
    for card in hand:
        for pile in range(len(all_discard_pile)):
            
            # to_player is the owner of the play card destination pile
            to_player = discard_pile_owner(discard_piles, pile)
            
            # put non-end play into play_list
            if comp10001bo_match_discard(card, all_discard_pile[pile], 
                                         player_no, to_player, 
                                         from_hand=True) == 1:
                
                play_list.append((0, card, (1, (to_player, pile%4))))
            
            # put end play into play_end_list
            elif comp10001bo_match_discard(card, all_discard_pile[pile], 
                                           player_no, to_player, 
                                           from_hand=True) == 2:
                
                play_end_list.append((0, card, (1, (to_player, pile%4))))
    
    # Sitution 5: play card from stock pile to discard piles
    for pile in range(len(all_discard_pile)):
        
        # to_player is the owner of the play card destination pile
        to_player = discard_pile_owner(discard_piles, pile)
        
        # put non-end play into play_list
        if comp10001bo_match_discard(stock_card, all_discard_pile[pile], 
                                     player_no, to_player, 
                                     from_hand=False) == 1:
            
            play_list.append((2, stock_card, (1, (to_player, pile%4))))
        
        # put end play into play_end_list
        elif comp10001bo_match_discard(stock_card, all_discard_pile[pile], 
                                       player_no, to_player, 
                                       from_hand=False) == 2:
           
            play_end_list.append((2, stock_card, (1, (to_player, pile%4))))
        
    # Sitution 6: play card from discard piles to discard piles
    for card in range(len(discard_card)):
        for pile in range(len(all_discard_pile)):
            if card != pile:
                
                # to_player is the owner of the play card destination pile
                to_player = discard_pile_owner(discard_piles, pile)
                
                # put non-end play into play_list
                if comp10001bo_match_discard(discard_card[card], 
                                             all_discard_pile[pile],
                                             player_no, to_player, 
                                             from_hand=False) == 1:
                    
                    play_list.append((1, (discard_card[card], 
                                          discard_position[card]), 
                                      (1, (to_player, pile%4))))
                
                # put end play into play_end_list
                elif comp10001bo_match_discard(discard_card[card], 
                                               all_discard_pile[pile],
                                               player_no, to_player, 
                                               from_hand=False) == 2:
                    
                    play_end_list.append((1, (discard_card[card], 
                                              discard_position[card]), 
                                          (1, (to_player, pile%4))))

    return play_list, play_end_list
     
    
def other_player(player_no):
    '''
    This function takes one argument, player_no is an int represent the current
    player number. This function will get a list of sequential player number 
    from the next player of the current player to the last player of the
    current player
    '''
    # other is a list to contain player number
    other = []
    
    # player is the current player number
    player = player_no
    
    # i is the initial number of players
    i = 0
    
    # Get the number of the players who after current player
    while player < 4:
        
        other.append(player)
        player += 1
    
    # Get the number of players who before current player
    while i < 4:
        
        other.append(i)
        i += 1
    
    # other_player is the final result of the list of the other players
    other_player = other[:3]
    
    return other_player 


def get_other_stock(player_no, hand, stockpiles, discard_piles, build_piles):
    '''
    This function will take all five arguments as same as previous function.
    This function will return all avaliable play by using other player's top
    stock cards.
    '''
    # A list will contain all avaliable play by using other player's stock card
    other_stock = []
    
    # all_discard_pile is a list contain all the 16 discard piles
    all_discard_pile = get_all_discard_piles(discard_piles)
    
    # Get a list of sequential player number from the next player to last 
    players = other_player(player_no)
    
    # Sitution 1: from other player's stock pile to build pile
    for player in players:
        
        # stock_card is the stock card of current player in the loop
        stock_card = stockpiles[player][0]
        
        for pile in range(len(build_piles)):

            if comp10001bo_match_build(stock_card, build_piles[pile]):
                
                other_stock.append((2, stock_card, (0, pile)))
    
    # Sitution 2: from other player's stock pile to discard pile
    for player in players:
        for pile in range(len(all_discard_pile)):
            
            stock_card = stockpiles[player][0]
        
            # to_player is the owner of the play card destination pile
            to_player = discard_pile_owner(discard_piles, pile)
            
            # Only get non-ending plays
            if comp10001bo_match_discard(stock_card, all_discard_pile[pile], 
                                         player, to_player, 
                                         from_hand=False) == 1:
              
                other_stock.append((2, stock_card, (1, (to_player, pile%4))))
    
    return other_stock
        
    
def stop_other_stock(player_no, hand, stockpiles, discard_piles, build_piles):
    '''
    This function takes five argument as same as previous function.
    This function will return avaliable plays that can stop other players play 
    from their stock piles
    '''
    
    # other_stock is the avaliable plays from other player's stock pile
    other_stock = get_other_stock(player_no, hand, stockpiles, 
                                  discard_piles, build_piles)
    
    # play_list is all the avaliable non-ending plays of current player
    play_list = get_all_play(player_no, hand, stockpiles, 
                             discard_piles, build_piles)[0]
    
    # a list will contain avaliable plays can stop other player's stock cards
    avaliable = []
    
    # Check there are avaliable play in each lists
    if play_list != [] and other_stock != []:
        
        for play in play_list:
            for other in other_stock:
                
                # Check destination of two plays
                if play[2] == other[2]:
                    avaliable.append(play)
    
    return avaliable
        
    
def check_from_hand(player_no, stockpiles, other):
    '''
    This function takes three argumnets, play_no is an integer represent 
    the player number; hand is a list contain all hand card of the player; 
    stockpiles is a 4-tuple describe the content of the stockpiles for each 
    player and the number of stockcard they have; other is the current play 
    in the loop.
    '''
    # stock is the top stock card of current player's stock pile
    stock = stockpiles[player_no][0]
    
    # other_card is the play card of current play in the loop
    other_card = other[1]
    
    # Check the play card to build piles
    if other[2][0] == 1:
        if check_discard_value(other_card, [stock]):
            
            return True
    
    # Check the play card to discard piles
    elif other[2][0] == 0:
        if check_build_value(other_card, [stock]):
            
            return True
    
    return False
    
    
def check_history(player_no, play_history):
    '''
    This function will take two arguments, player_no is an int represents the 
    current player, play_history is the history of all passed plays that played
    before this play. This function will return a int that represent how many 
    plays did the player did in this turn.
    '''
    # own_play is the int representing how many times play is this play in turn
    own_play = 0
    
    for history in play_history:
        
        # Get the plays played by current player
        if history[0] == player_no:
            own_play += 1
            
    return own_play
    
    
def comp10001bo_play(player_no, hand, stockpiles, discard_piles, 
                     build_piles, play_history):
    
    # play_list is the avaliable non-ending play of current player
    play_list = get_all_play(player_no, hand, stockpiles, 
                             discard_piles, build_piles)[0]
    
    # play_end is the avaliable ending play of current player
    play_end = get_all_play(player_no, hand, stockpiles, 
                            discard_piles, build_piles)[1]
    
    # stop_other is the avaliable plays that can stop other players stock card
    stop_other = stop_other_stock(player_no, hand, stockpiles, 
                                  discard_piles, build_piles)
    
    # from_stock is all the avaliable non-ending stock play of current player
    from_stock = []
    
    # from_other is all the avaliable non-ending non-stock play
    from_other = []
    
    # from_stock_end is all the avaliable ending plays from stock pile
    from_stock_end = []
    
    # from_stock_end is all the avaliable ending plays not from stock pile
    from_other_end = []
    
    # step_no is in which time the current play is in this turn
    step_no = check_history(player_no, play_history) + 1
    
    # Split the non-ending play by from stockpile or not
    if play_list != []:
        
        for play in play_list:
            
            if play[0] == 2:
                from_stock.append(play)
        
            else:
                from_other.append(play)
    
    # Split ending play by from stockpile or not
    elif play_end != []:
        
        for play in play_end:
            
            if play[0] == 2:
                from_stock_end.append(play)
            
            else:
                from_other_end.append(play)
    
    # other_stock is all the avaliable plays from other player's stock piles
    other_stock = get_other_stock(player_no, hand, stockpiles, 
                                  discard_piles, build_piles)
    
    # better_play is non-end plays will not make bridge cards for other_stock
    better_play = []
    
    # better_play_end is end plays will not make bridge cards for other_stock
    better_play_end = []
    
    # better_play is non-end stock will not make bridge cards for other_stock
    better_stock = []
    
    # better_play is end stock play will not make bridge cards for other_stock
    better_stock_end = []
               
    # Get plays from other players' stock piles
    for otherstock in other_stock:
        
        # othercard is the stock card from other player
        othercard = otherstock[1] 
        
        # Sitution 1: Get better non-ending play
        # Get non-ending play, play is non-ending play from current player    
        for play in from_other:
            
            # Play card from discard pile
            if play[0] == 1:
                
                # playcard is the card to play
                playcard = play[1][0]
                
            # Play card from hand
            elif play[0] == 0:
                
                # playcard is the card to play
                playcard = play[1]
            
            # Check two plays's destination are same and to discard pile
            if play[2] == otherstock[2] and play[2][0] == 1:
                
                # Get no matching plays
                if not check_discard_value(playcard, [othercard]):
                    
                    better_play.append(play)
                    
            # Check two plays's destination are same and to build piles
            elif play[2] == otherstock[2] and play[2][0] == 0:
                
                # Get no matching plays
                if ((not check_build_value(playcard, [othercard])) or 
                        playcard[0] == "A"):
                
                    better_play.append(play)
        
        # Sitution 2: Get better ending play 
        # Get ending play, playend is the ending play from current pkayer 
        for playend in from_other_end:
        
            
            # Play card from discard pile
            if playend[0] == 1:
                
                # playcard is the card to play
                playcard = playend[1][0]
            
            # Play card from hand
            elif playend[0] == 0:
                
                # playcard is the card to play
                playcard = playend[1]
            
            # Check two plays's destination are same and to discard piles
            if playend[2] == otherstock[2] and playend[2][0] == 1:
                
                # Get no matching plays
                if check_discard_value(playcard, [othercard]):
                    
                    better_play_end.append(playend)
            
            # Check two plays's destination are same and to build piles
            elif playend[2] == otherstock[2] and playend[2][0] == 0:
                
                # Get no matching plays
                if ((not check_build_value(playcard, [othercard])) or 
                        playcard[0] == "A"):
                    
                    better_play_end.append(playend)
        
        # Sitution 3: Get better stock non-ending plays
        # Get non ending stock card, sock is the stock play from current pkayer
        for stock in from_stock:
            
            # stockcard is the stock card
            stockcard = stock[1]
            
            # Check two plays's destination are same and to discard pile
            if stock[2] == otherstock[2] and stock[2][0] == 1:
                
                # Get no matching plays
                if not check_discard_value(stockcard, [othercard]):
                    
                    better_stock.append(stock)
                    
            # Check two plays's destination are same and to build piles
            elif stock[2] == otherstock[2] and stock[2][0] == 0:
                
                # Get no matching plays
                if ((not check_build_value(stockcard, [othercard])) or 
                        stockcard[0] == "A"):
                    
                    better_stock.append(stock)
        
        # Sitution 4: Get better stock ending plays
        # Get ending stock play, stockend is the ending stock plays
        for stockend in from_stock_end:
            
            # stockcard is the stock card
            stockcard = stockend[1]
            
            # Check two plays's destination are same and to discard pile
            if stockend[2] == otherstock[2] and stockend[2][0] == 1:
                
                # Get no matching plays
                if not check_discard_value(stockcard, [othercard]):
                    
                    better_stock_end.append(stockend)
                    
            # Check two plays's destination are same and to build piles
            elif stockend[2] == otherstock[2] and stockend[2][0] == 0:
                
                # Get no matching plays
                if ((not check_build_value(stockcard, [othercard])) or 
                        stockcard[0] == "A"):
                    
                    better_stock_end.append(stockend)

                
    # Play Option 1-1: play non-ending non-bridge stock card
    if better_stock != []:
    
        return better_stock[0]
    
    # Play Option 1-2: play non_ending stock card
    elif from_stock != []:
        
        return from_stock[0]
    
    # Play Option 2: play non-ending other card
    elif from_other != []:
        
        for other in from_other:
            
            # Play Option 2-1: from hand to build
            if other[0] == 0 and other[2][0] == 0:
                
                if check_from_hand(player_no, stockpiles, other):
                    
                    return other
            
            # Play Option 2-2: from hand to discard
            elif other[0] == 0 and other[2][0] == 1:

                if check_from_hand(player_no, stockpiles, other):
                    
                    return other
            
            # Play Option 2-3: from discard to build
            elif other[0] == 1 and other[2][0] == 0:

                # position is the position of the play card from
                position = other[1][1]
                
                # Check the discard pile has more than one card
                # Then check the second top card can be bridge card for stock
                if len(discard_piles[position[0]][position[1]]) > 1:
                    
                    # card is the second top card from discard pile
                    card = discard_piles[position[0]][position[1]][-2]
                    
                    # stock is the player's own stock card
                    stock = stockpiles[player_no][0]
                    
                    # Check the second top be bridge card in build 
                    if check_build_value(card, [stock]):
                        
                        return other
            
            # Play Option 2-4: from discard to discard
            elif other[0] == 1 and other[2][0] == 1:

                # position is the position of the play card from
                position = other[1][1]

                # Check the discard pile has more than one card
                # Then check the second top card can be bridge card for stock
                if len(discard_piles[position[0]][position[1]]) > 1:
                    
                    # card is the second top card from discard pile
                    card = discard_piles[position[0]][position[1]][-2]
                    
                    # stock is the player's own stock card
                    stock = stockpiles[player_no][0]
                    
                    # Check the second top be bridge card in discard
                    if check_discard_value(card, [stock]):
                        
                        return other
        
        # Play Option 2-5: play card to stop other's stock
        if stop_other != [] and step_no == 5:
                
            return stop_other[0]
        
        # Play Option 2-6: play ending non-bridge stock card
        elif better_stock_end != []:
            
            return better_stock_end[0]
        
        # Play Option 2-7: play ending stock card
        elif from_stock_end != []:
            
            return from_stock_end[0]
        
        # Play Option 2-8: play card that will not be other's bridge card
        elif better_play != []:  # Non-ending Play
            
            return better_play[0]

        # Play Option 2-9: play end card that will not be other's bridge card
        elif better_play_end != [] and step_no == 5:  # Last play of this turn 
            
            return better_play_end[0]
        
        # Play Option 2-10: play non-ending play from hand or discard randomly
        else:
            return from_other[0]
    
    # Play Option 3-1: play non-bridge ending play from stock pile
    elif better_stock_end != []:
        
        return better_stock_end[0]
    
    # Play Option 3-2: Play ending plays from stock
    elif from_stock_end != []:
    
        return from_stock_end[0]
    
    # Play Option 4-1: Play non-bridge ending play from other
    elif better_play_end != []:
        
        return better_play_end[0]
        
    # Play Option 4-2: play ending play from other 
    elif from_other_end != []:
    
        return from_other_end[0]
    
    # Play Option 5: no possible play
    else:
    
        return (3, None, (None, None))
